<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>

<body>
    <canvas id="webgl" width="640" height="480"></canvas>

    <script type="text/javascript">
        //
        // Initialize a texture and load an image.
        // When the image finished loading copy it into the texture.
        //
        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be downloaded over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

            const image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    srcFormat, srcType, image);

                // WebGL1 has different requirements for power of 2 images
                // vs non power of 2 images so check if the image is a
                // power of 2 in both dimensions.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn off mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            };
            image.src = url;

            return texture;
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) == 0;
        }








        let assert = (condition, msg) => {
            if (!condition) throw msg;
        }
        const VERTEX_SHADER_SOURCE =
            "attribute vec3 pos;" +
            "void main() {" +
            "	gl_Position = vec4(pos, 1.0);" +
            "}"
        const FRAGMENT_SHADER_SOURCE =
            "void main() {" +
            "	gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);" +
            "}"







        function draw() {
            var gl = document.getElementById("webgl")
                .getContext("experimental-webgl");
            gl.clearColor(0.8, 0.8, 0.8, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);


            var prog = gl.createProgram();



            var s = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(s, VERTEX_SHADER_SOURCE);
            gl.compileShader(s);
            assert(gl.getShaderParameter(s, gl.COMPILE_STATUS), "expect to compile vertext shader")
            gl.attachShader(prog, s);

            var s = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(s, FRAGMENT_SHADER_SOURCE);
            gl.compileShader(s);
            assert(gl.getShaderParameter(s, gl.COMPILE_STATUS), "expect to compile frag shader")
            gl.attachShader(prog, s);


            gl.linkProgram(prog);




            assert(gl.getProgramParameter(prog, gl.LINK_STATUS), "expected to link the shader programs");


            gl.useProgram(prog);


            let arr = [-1, 0, 0,
                0, 1, 0,
                0, -1, 0,
                0.1, 1, 0,
                0.1, -1, 0,
                1, 0, 0
            ]

            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.DYNAMIC_DRAW);
            var attr = gl.getAttribLocation(prog, "pos");
            gl.enableVertexAttribArray(attr);
            gl.vertexAttribPointer(attr, 3, gl.FLOAT, false, 0, 0);






            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            const textureCoordinates = [
                // Front
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                // Back
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                // Top
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                // Bottom
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                // Right
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                // Left
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                gl.STATIC_DRAW);









            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        draw();
    </script>
</body>

</html>